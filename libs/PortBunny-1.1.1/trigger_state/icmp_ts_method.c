#include "icmp_ts_method.h"
#include "trigger_finding_methods.h"
#include "state.h"

#include "../scanner_module.h"
#include "../packet_submitter.h"
#include "../scan_job_states.h"
#include "../sniffer/sniffed_packet.h"

#include "../flood_state/packet_batch.h"

#include <linux/time.h>
#include <net/ip.h>

struct packet_batch;

/***************************************************/

/*
  TODO: For some reason, wireshark marks the packets
  generated by this function as malformed.
  In my opinion, the timestamp is correct...
*/

static void icmp_ts_sender(struct scan_job_t *this,
			   struct trigger_instance *method_instance)
{
	
	struct icmp_ts_context *context = method_instance->context;
	/* data: number of milliseconds since start of epoch */
	struct timespec tv;
	__u32 time;

	int icmp_data_size = 4;
	char *icmp_data = kmalloc(icmp_data_size, GFP_KERNEL);
				

	if(!icmp_data) return;
	
	/* prepare icmp-data: In an icmp-time-stamp the
	   data-field is 32 bit long and contains the number
	   of milliseconds since midnight UTC.
	
	   FIXME.
	
	*/
	
	tv = CURRENT_TIME;;
	time = htonl( (tv.tv_sec % 86400) * 1000 + (tv.tv_nsec / NSEC_PER_MSEC));
	memcpy(icmp_data, &time, icmp_data_size);
	
	send_icmp_packet(this->addr, ICMP_TIMESTAMP,
			 0, icmp_data_size, icmp_data,
			 context->batch_id);	
		
	kfree(icmp_data);

}



static int icmp_ts_receiver(struct scan_job_t *this,
			    struct trigger_instance *method_instance,
			    struct sniffed_packet_descr_t *descr)
{
	struct trigger_state_context *context =
		(struct trigger_state_context *) this->state_context;
		
	/* If protocol and icmp-type is correct, the packet
	   is from the host this scan-job is scanning and
	   this trigger has not been reported, report it.
	*/
	if( (descr->protocol == IPPROTO_ICMP) &&
	    (descr->icmp.type == ICMP_TIMESTAMPREPLY) &&
	    (descr->src == this->addr)){
	  
		trigger_instance_out(method_instance, this, 0);
		context->ntriggers_found++;
		return FINISHED;
	}			
	
	
	return CALL_AGAIN;
}

static int icmp_ts_is_response(struct sniffed_packet_descr_t *descr,
			       struct packet_batch *batch)
{
	u32 batch_id = descr->icmp.id;
		
		
	return  (batch_id == batch->port_indices[0]) &&
		(descr->protocol == IPPROTO_ICMP) &&
		(descr->icmp.type == ICMP_TIMESTAMPREPLY);
}

static int icmp_ts_context_init(struct trigger_instance *this,
				s32 unused)
{
	struct icmp_ts_context *context = 
		this->context = kmalloc(sizeof(struct icmp_ts_context),
					GFP_KERNEL);

	if(!context)
		return FAILURE;
	memset(this->context, 0, sizeof(struct icmp_ts_context));
	
	this->quality = ICMP_TS_QUALITY;
	
	return SUCCESS;
	
}


static u32 icmp_ts_extract_batch_id(struct sniffed_packet_descr_t *descr)
{
	if ((descr->protocol == IPPROTO_ICMP) &&
	    (descr->icmp.type == ICMP_TIMESTAMPREPLY))
		return descr->icmp.id;
	
	return 0;
}


static void icmp_ts_register_batch_id(struct trigger_instance *this,
				      u32 batch_id)
{
	struct icmp_ts_context *context = this->context;
	
	/* Save batch_id in id */
	context->batch_id = batch_id;
	
}


static void icmp_ts_context_fini(struct trigger_instance *this)
{
	struct icmp_ts_context *context = this->context;
		
	kfree(context);	
}


static void *
icmp_ts_context_copy(struct trigger_instance *this)
{
	struct icmp_ts_context *context = this->context;
	
	struct icmp_ts_context *new_context = 
		kmalloc(sizeof(struct icmp_ts_context), GFP_KERNEL);

	if(!new_context)
		return NULL;

	memcpy(new_context, context, sizeof(struct icmp_ts_context));
	
	return new_context;
	
}

s32 icmp_ts_get_round_by_descr(struct sniffed_packet_descr_t *descr)
{
	return 0;
}

static s32 icmp_ts_get_round(void *context)
{
	return 0;
}

static u8 icmp_ts_get_default_quality(void)
{
	return ICMP_TS_QUALITY;
}

struct trigger_finding_method icmp_ts_method = {
	.name = "ICMP_TS",
	.sender_func = &icmp_ts_sender,
	.large_sender_func = NULL,
	.receiver_func = &icmp_ts_receiver,
	
	.is_response = &icmp_ts_is_response,
	.register_batch_id = &icmp_ts_register_batch_id,
	.extract_batch_id  = &icmp_ts_extract_batch_id,
	
	.get_round_by_descr = &icmp_ts_get_round_by_descr,
	.get_round          = &icmp_ts_get_round,

	.get_default_quality = &icmp_ts_get_default_quality,

	.context_init = icmp_ts_context_init,
	.context_fini = icmp_ts_context_fini,
	
	.context_copy = icmp_ts_context_copy,
		
};
