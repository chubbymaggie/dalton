!<arch>
__.PKGDEF       0           0     0     644     20831     `
go object linux amd64 go1.5.1 X:none
build id "9b576e41637a42e09e0c4a177a6921266e837893"

$$
package crypt
	import runtime "runtime"
	import fmt "fmt"
	import cipher "crypto/cipher"
	import aes "crypto/aes"
	import rsa "crypto/rsa"
	import crypto "crypto"
	import rand "crypto/rand"
	import ioutil "io/ioutil"
	import pem "encoding/pem"
	import x509 "crypto/x509"
	import sha1 "crypto/sha1"
	type @"".CryptoManager struct { IV []byte; SymmetricKey []byte; KeySize int }
	func (@"".symmÂ·3 *@"".CryptoManager "esc:0x9") Decrypt (@"".dataÂ·4 []byte) (@"".decryptDataÂ·1 []byte, @"".errÂ·2 error)
	func (@"".symmÂ·3 *@"".CryptoManager "esc:0x9") Encrypt (@"".dataÂ·4 []byte) (@"".encryptedDataÂ·1 []byte, @"".errÂ·2 error)
	func (@"".symmÂ·1 *@"".CryptoManager "esc:0x1") SetIV (@"".ivÂ·2 []byte) { @"".symmÂ·1.IV = @"".ivÂ·2 }
	func (@"".symmÂ·1 *@"".CryptoManager "esc:0x1") SetKey (@"".keyÂ·2 []byte) { @"".symmÂ·1.SymmetricKey = @"".keyÂ·2 }
	func (@"".symmÂ·1 *@"".CryptoManager "esc:0x1") SetKeySize (@"".keysizeÂ·2 int) { @"".symmÂ·1.KeySize = @"".keysizeÂ·2 }
	import big "math/big" // indirect
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") ExpFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Float32 () (? float32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Float64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int () (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int31 () (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int31n (@"math/rand".nÂ·3 int32) (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int63 () (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int63n (@"math/rand".nÂ·3 int64) (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Intn (@"math/rand".nÂ·3 int) (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") NormFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Perm (@"math/rand".nÂ·3 int) (? []int)
	func (@"math/rand".rÂ·1 *@"math/rand".Rand "esc:0x9") Seed (@"math/rand".seedÂ·2 int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Uint32 () (? uint32)
	import io "io" // indirect
	type @"io".ByteScanner interface { ReadByte() (@"io".c byte, @"io".err error); UnreadByte() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".add (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".and (@"math/big".xÂ·3 @"math/big".nat "esc:0x1", @"math/big".yÂ·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".andNot (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".yÂ·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".bit (@"math/big".iÂ·3 uint) (? uint) { var @"math/big".jÂ·4 uint; ; @"math/big".jÂ·4 = @"math/big".iÂ·3 / 0x40; if @"math/big".jÂ·4 >= uint(len(@"math/big".xÂ·2)) { return 0x0 }; return uint(@"math/big".xÂ·2[@"math/big".jÂ·4] >> (@"math/big".iÂ·3 % 0x40) & @"math/big".Word(0x1)) }
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".bitLen () (? int)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".bytes (@"math/big".bufÂ·3 []byte "esc:0x1") (@"math/big".iÂ·1 int)
	func (@"math/big".zÂ·1 @"math/big".nat "esc:0x1") @"math/big".clear ()
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".cmp (@"math/big".yÂ·3 @"math/big".nat "esc:0x1") (@"math/big".rÂ·1 int)
	func (@"math/big".qÂ·1 @"math/big".nat) @"math/big".convertWords (@"math/big".sÂ·2 []byte "esc:0x1", @"math/big".charsetÂ·3 string "esc:0x1", @"math/big".bÂ·4 @"math/big".Word, @"math/big".ndigitsÂ·5 int, @"math/big".bbÂ·6 @"math/big".Word, @"math/big".tableÂ·7 []@"math/big".divisor "esc:0x9")
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x9") @"math/big".decimalString () (? string)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".div (@"math/big".z2Â·4 @"math/big".nat, @"math/big".uÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat "esc:0x12") @"math/big".divLarge (@"math/big".uÂ·4 @"math/big".nat, @"math/big".uInÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".divW (@"math/big".xÂ·4 @"math/big".nat, @"math/big".yÂ·5 @"math/big".Word) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNN (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNMontgomery (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expWW (@"math/big".xÂ·3 @"math/big".Word, @"math/big".yÂ·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x9") @"math/big".hexString () (? string)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".make (@"math/big".nÂ·3 int) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat) @"math/big".modW (@"math/big".dÂ·3 @"math/big".Word) (@"math/big".rÂ·1 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".montgomery (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat, @"math/big".kÂ·6 @"math/big".Word, @"math/big".nÂ·7 int) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mul (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".Word, @"math/big".rÂ·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulRange (@"math/big".aÂ·3 uint64, @"math/big".bÂ·4 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".or (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".yÂ·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".nÂ·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".repsÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".random (@"math/big".randÂ·3 *@"math/rand".Rand "esc:0x9", @"math/big".limitÂ·4 @"math/big".nat "esc:0x1", @"math/big".nÂ·5 int) (? @"math/big".nat)
	func (@"math/big".zÂ·5 @"math/big".nat) @"math/big".scan (@"math/big".rÂ·6 @"io".ByteScanner, @"math/big".baseÂ·7 int, @"math/big".fracOkÂ·8 bool) (@"math/big".resÂ·1 @"math/big".nat, @"math/big".bÂ·2 int, @"math/big".countÂ·3 int, @"math/big".errÂ·4 error)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".set (@"math/big".xÂ·3 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setBit (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".iÂ·4 uint, @"math/big".bÂ·5 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setBytes (@"math/big".bufÂ·3 []byte "esc:0x1") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setUint64 (@"math/big".xÂ·3 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setWord (@"math/big".xÂ·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shl (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shr (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".sticky (@"math/big".iÂ·3 uint) (? uint)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x9") @"math/big".string (@"math/big".charsetÂ·3 string "esc:0x1") (? string)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".sub (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".xor (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".yÂ·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Abs (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Add (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") And (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") AndNot (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Binomial (@"math/big".nÂ·3 int64, @"math/big".kÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") Bit (@"math/big".iÂ·3 int) (? uint)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") BitLen () (? int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x22") Bits () (? []@"math/big".Word) { return @"math/big".xÂ·2.@"math/big".abs }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Bytes () (? []byte)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Cmp (@"math/big".yÂ·3 *@"math/big".Int "esc:0x1") (@"math/big".rÂ·1 int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Div (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x1a") DivMod (@"math/big".xÂ·4 *@"math/big".Int "esc:0x9", @"math/big".yÂ·5 *@"math/big".Int "esc:0x9", @"math/big".mÂ·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Exp (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x1", @"math/big".mÂ·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·1 *@"math/big".Int "esc:0x9") Format (@"math/big".sÂ·2 @"fmt".State, @"math/big".chÂ·3 rune)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") GCD (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9", @"math/big".aÂ·5 *@"math/big".Int "esc:0x9", @"math/big".bÂ·6 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") GobDecode (@"math/big".bufÂ·3 []byte "esc:0x1") (? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Int64 () (? int64) { var @"math/big".vÂ·3 int64; ; @"math/big".vÂ·3 = int64(@"math/big".low64(@"math/big".xÂ·2.@"math/big".abs)); if @"math/big".xÂ·2.@"math/big".neg { @"math/big".vÂ·3 = -@"math/big".vÂ·3 }; return @"math/big".vÂ·3 }
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Lsh (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x9") MarshalText () (@"math/big".textÂ·1 []byte, @"math/big".errÂ·2 error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Mod (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") ModInverse (@"math/big".gÂ·3 *@"math/big".Int "esc:0x9", @"math/big".nÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") ModSqrt (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".pÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Mul (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") MulRange (@"math/big".aÂ·3 int64, @"math/big".bÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Neg (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Not (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Or (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") ProbablyPrime (@"math/big".nÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Quo (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x1a") QuoRem (@"math/big".xÂ·4 *@"math/big".Int "esc:0x9", @"math/big".yÂ·5 *@"math/big".Int "esc:0x9", @"math/big".rÂ·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Rand (@"math/big".rndÂ·3 *@"math/rand".Rand "esc:0x9", @"math/big".nÂ·4 *@"math/big".Int "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Rem (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Rsh (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") Scan (@"math/big".sÂ·3 @"fmt".ScanState, @"math/big".chÂ·4 rune) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Set (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetBit (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".iÂ·4 int, @"math/big".bÂ·5 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x12") SetBits (@"math/big".absÂ·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetBytes (@"math/big".bufÂ·3 []byte "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetInt64 (@"math/big".xÂ·3 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x1a") SetString (@"math/big".sÂ·4 string, @"math/big".baseÂ·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetUint64 (@"math/big".xÂ·3 uint64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Sign () (? int) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; if @"math/big".xÂ·2.@"math/big".neg { return -0x1 }; return 0x1 }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") String () (? string)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Sub (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Uint64 () (? uint64) { return @"math/big".low64(@"math/big".xÂ·2.@"math/big".abs) }
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") UnmarshalJSON (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") UnmarshalText (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Xor (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") @"math/big".binaryGCD (@"math/big".aÂ·3 *@"math/big".Int "esc:0x9", @"math/big".bÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·4 *@"math/big".Int "esc:0x1a") @"math/big".scan (@"math/big".rÂ·5 @"io".ByteScanner, @"math/big".baseÂ·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/rsa".PublicKey struct { N *@"math/big".Int; E int }
	type @"crypto/rsa".CRTValue struct { Exp *@"math/big".Int; Coeff *@"math/big".Int; R *@"math/big".Int }
	type @"crypto/rsa".PrecomputedValues struct { Dp *@"math/big".Int; Dq *@"math/big".Int; Qinv *@"math/big".Int; CRTValues []@"crypto/rsa".CRTValue }
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"crypto".DecrypterOpts interface {}
	type @"crypto".PublicKey interface {}
	import hash "hash" // indirect
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"crypto".Hash uint
	func (@"crypto".hÂ·2 @"crypto".Hash) Available () (? bool) { return @"crypto".hÂ·2 < @"crypto".Hash(0x10) && @"crypto".hashes[@"crypto".hÂ·2] != nil }
	func (@"crypto".hÂ·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".hÂ·2 }
	func (@"crypto".hÂ·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".hÂ·2 @"crypto".Hash) Size () (? int)
	type @"crypto".SignerOpts interface { HashFunc() (? @"crypto".Hash) }
	type @"crypto/rsa".PrivateKey struct { ? @"crypto/rsa".PublicKey; D *@"math/big".Int; Primes []*@"math/big".Int; Precomputed @"crypto/rsa".PrecomputedValues }
	func (@"crypto/rsa".privÂ·3 *@"crypto/rsa".PrivateKey "esc:0x9") Decrypt (@"crypto/rsa".randÂ·4 @"io".Reader, @"crypto/rsa".ciphertextÂ·5 []byte "esc:0x1", @"crypto/rsa".optsÂ·6 @"crypto".DecrypterOpts "esc:0x9") (@"crypto/rsa".plaintextÂ·1 []byte, @"crypto/rsa".errÂ·2 error)
	func (@"crypto/rsa".privÂ·1 *@"crypto/rsa".PrivateKey "esc:0x9") Precompute ()
	func (@"crypto/rsa".privÂ·2 *@"crypto/rsa".PrivateKey "esc:0x12") Public () (? @"crypto".PublicKey) { return &@"crypto/rsa".privÂ·2.PublicKey }
	func (@"crypto/rsa".privÂ·3 *@"crypto/rsa".PrivateKey "esc:0x9") Sign (@"crypto/rsa".randÂ·4 @"io".Reader, @"crypto/rsa".msgÂ·5 []byte, @"crypto/rsa".optsÂ·6 @"crypto".SignerOpts) (? []byte, ? error)
	func (@"crypto/rsa".privÂ·2 *@"crypto/rsa".PrivateKey "esc:0x9") Validate () (? error)
	type @"".Signer struct { PrivateKey *@"crypto/rsa".PrivateKey; PublicKey *@"crypto/rsa".PublicKey }
	func (@"".signerÂ·2 *@"".Signer "esc:0x1") HashMessage (@"".messageÂ·3 []byte) (@"".hashedContentsÂ·1 []byte)
	func (@"".signerÂ·2 *@"".Signer "esc:0x1") InitSigner (@"".privPathÂ·3 string, @"".PubPathÂ·4 string) (@"".errÂ·1 error)
	func (@"".signerÂ·2 *@"".Signer "esc:0x9") LoadPrivateKey (@"".pathÂ·3 string) (? error)
	func (@"".signerÂ·2 *@"".Signer "esc:0x1") LoadPublicKey (@"".pathÂ·3 string) (? error)
	func (@"".signerÂ·3 *@"".Signer "esc:0x9") SignContents (@"".contentsÂ·4 []byte) (@"".signedContentsÂ·1 []byte, @"".errÂ·2 error)
	func (@"".signerÂ·2 *@"".Signer "esc:0x9") VerifyContents (@"".contentsÂ·3 []byte, @"".signedContentsÂ·4 []byte "esc:0x1") (? bool)
	func @"".init ()
	func @"math/big".low64 (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") (? uint64) { if len(@"math/big".zÂ·2) == 0x0 { return 0x0 }; var @"math/big".vÂ·3 uint64; ; @"math/big".vÂ·3 = uint64(@"math/big".zÂ·2[0x0]); if false && len(@"math/big".zÂ·2) > 0x1 { @"math/big".vÂ·3 |= uint64(@"math/big".zÂ·2[0x1]) << 0x20 }; return @"math/big".vÂ·3 }
	var @"crypto".hashes []func() (? @"hash".Hash)

$$
 _go_.o          0           0     0     644     41795     `
go object linux amd64 go1.5.1 X:none

!
  go13ld
fmt.acrypto/cipher.acrypto/aes.acrypto/rsa.aio/ioutil.aencoding/pem.acrypto/x509.acrypto/sha1.acrypto.acrypto/rand.a ş2"".(*CryptoManager).SetIV  À  ®dH‹%    H;avAHƒìH‹\$H‹l$(H‰kH‹l$0H‰kH‹l$ €=     uH‰+HƒÄÃH‰$H‰l$è    ëëè    ë©
      b 6runtime.writeBarrierEnabled   ”
  .runtime.writebarrierptr   ¢
  0runtime.morestack_noctxt   @   
"".iv type.[]uint8 "".symm  ,type.*"".CryptoManager  ,   ` $( 
 I TgclocalsÂ·0ebb2d1da58c1b4224bf5a7b370d7578 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   ‚/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/aes.goş4"".(*CryptoManager).SetKey  À  ¸dH‹%    H;avFHƒìH‹\$H‹l$(H‰k H‹l$0H‰k(H‹l$ €=     u	H‰kHƒÄÃLCL‰$H‰l$è    ëçè    ë¤
      b 6runtime.writeBarrierEnabled   
  .runtime.writebarrierptr   ¬
  0runtime.morestack_noctxt   @   "".key type.[]uint8 "".symm  ,type.*"".CryptoManager  -  ` ,) 
 N TgclocalsÂ·0ebb2d1da58c1b4224bf5a7b370d7578 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   ‚/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/aes.goş<"".(*CryptoManager).SetKeySize     H‹\$H‹l$H‰k0Ã     "".keysize type.int "".symm  ,type.*"".CryptoManager   
6  TgclocalsÂ·3f5c1f818fa7055d0400cecd34057162 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   ‚/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/aes.goş6"".(*CryptoManager).Encrypt  À  ¸dH‹%    H;a†  HƒìXH‹D$`1Û1Û1ÛH‰œ$˜   H‰œ$    1ÛH‰œ$€   H‰œ$ˆ   H‰œ$   H‹X0Hƒû „ï   H‹hHƒı „á   H‹(Hƒı „Ô   H‰$è    H‹L$H‹D$H‰L$HH‰$H‰D$PH‰D$H‹t$`H|$H‹H‰H‹NH‰OH‹NH‰Oè    H‹T$hH‹L$pH‹D$xH‹t$(H‹l$0H‰T$H‰L$H‰D$H‰T$ H‰L$(H‰D$0H‰l$@H‰,$H‰t$8H‹^ ÿÓH‹\$hH‰œ$€   H‹\$pH‰œ$ˆ   H‹\$xH‰œ$   1ÛH‰œ$˜   H‰œ$    HƒÄXÃH    H‰$HÇD$s   1ÛH‰\$H‰\$H‰\$ è    H‹\$(H‰œ$˜   H‹\$0H‰œ$    HƒÄXÃè    édşÿÿ
      ô
  "".makeCipher   ø
  (crypto/cipher.NewCTR   ’       ˜  ""..gostring.1   Ş
  fmt.Errorf   ¦
  0runtime.morestack_noctxt   °  "".stream ?2type.crypto/cipher.Stream "".blockCipher 0type.crypto/cipher.Block "".err ptype.error  "".encryptedData @type.[]uint8 "".data type.[]uint8 "".symm  ,type.*"".CryptoManager &°±¯°H¯°   .:L)
Q2'D	  yõ2 TgclocalsÂ·8b959903a1683cc7c5ff1a0817f89906 TgclocalsÂ·64ca935d1a2110a30e2d604686188539   ‚/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/aes.goş6"".(*CryptoManager).Decrypt  À  ¸dH‹%    H;a†  HƒìXH‹D$`1Û1Û1ÛH‰œ$˜   H‰œ$    1ÛH‰œ$€   H‰œ$ˆ   H‰œ$   H‹X0Hƒû „ï   H‹hHƒı „á   H‹(Hƒı „Ô   H‰$è    H‹L$H‹D$H‰L$HH‰$H‰D$PH‰D$H‹t$`H|$H‹H‰H‹NH‰OH‹NH‰Oè    H‹T$hH‹L$pH‹D$xH‹t$(H‹l$0H‰T$H‰L$H‰D$H‰T$ H‰L$(H‰D$0H‰l$@H‰,$H‰t$8H‹^ ÿÓH‹\$hH‰œ$€   H‹\$pH‰œ$ˆ   H‹\$xH‰œ$   1ÛH‰œ$˜   H‰œ$    HƒÄXÃH    H‰$HÇD$s   1ÛH‰\$H‰\$H‰\$ è    H‹\$(H‰œ$˜   H‹\$0H‰œ$    HƒÄXÃè    édşÿÿ
      ô
  "".makeCipher   ø
  (crypto/cipher.NewCTR   ’       ˜  ""..gostring.2   Ş
  fmt.Errorf   ¦
  0runtime.morestack_noctxt   °  "".stream ?2type.crypto/cipher.Stream "".blockCipher 0type.crypto/cipher.Block "".err ptype.error "".decryptData @type.[]uint8 "".data type.[]uint8 "".symm  ,type.*"".CryptoManager &°±¯°H¯°   .ZL)Q2'D  yõ2 TgclocalsÂ·8b959903a1683cc7c5ff1a0817f89906 TgclocalsÂ·64ca935d1a2110a30e2d604686188539   ‚/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/aes.goş"".makeCipher     ˜dH‹%    H;a†¯   HƒìX1ÛH‰\$hH‰\$pH‹t$`Hƒş „‰   H^H‹H‰$H‹KH‰L$H‹KH‰L$è    H‹l$H‰l$HH‹T$ H‰T$PH‹D$(H‹L$0Hƒø t4H‰D$8H‰$H‰L$@H‰L$è    H\$H‹H‰$H‹KH‰L$è    H‰l$hH‰T$pHƒÄXÃ‰épÿÿÿè    é4ÿÿÿ

       
  (crypto/aes.NewCipher   ˜
  runtime.convI2E   Ì
  runtime.gopanic   †
  0runtime.morestack_noctxt   0°  "".err ?type.error "".c 0type.crypto/cipher.Block "".~r1 0type.crypto/cipher.Block "".symm  ,type.*"".CryptoManager °£¯° Ğ v#O4  O TgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2 TgclocalsÂ·a8eabfc4a4514ed6b3b0c61e9680e440   ‚/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/aes.goş."".(*Signer).InitSigner  à  ÄdH‹%    H;a†  Hƒì1ÛH‰\$HH‰\$P1ÛH‰\$HH‰\$PH\$HH‰\$Ç$   H    H‰D$è    ƒø …³   H‹\$(H‰$H‹\$0H‰\$è    H‹D$H‹\$ Hƒû „€   €=     ugH‰H‹\$8H‰$H‹\$@H‰\$è    H‹L$H‹\$ Hƒû t8€=     uH‰K1ÛH‰\$HH‰\$Pè    HƒÄÃLCL‰$H‰L$è    ëÕ‰ëÄH‰$H‰D$è    ëŒ‰éyÿÿÿè    HƒÄÃè    éŞşÿÿ
      †  @"".(*Signer).InitSigner.func1Â·f   š
  "runtime.deferproc   Ü
  """.loadPrivateKey    6runtime.writeBarrierEnabled   Ì
   "".loadPublicKey   ø 6runtime.writeBarrierEnabled   ª
  &runtime.deferreturn   Ø
  .runtime.writebarrierptr   €
  .runtime.writebarrierptr   
  &runtime.deferreturn   ²
  0runtime.morestack_noctxt   p0  "".err Ptype.error "".PubPath 0type.string "".privPath type.string "".signer  type.*"".Signer 0Æ/09/0 ° *$/+85  Lä TgclocalsÂ·61be611d0884f5694642c4f84809f991 TgclocalsÂ·69c1753bd5f81501d95132d08af04464   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş6"".(*Signer).LoadPrivateKey     ˆdH‹%    H;a†§   Hƒì1ÛH‰\$8H‰\$@H‹\$(H‰$H‹\$0H‰\$è    H‹L$ H‹D$Hƒù tk€=     uMH‰Hƒù t@H‹)Hƒı t2€=     uH‰i1ÛH‰\$8H‰\$@HƒÄÃLAL‰$H‰l$è    ëÛ‰E ëÉ‰ë¼H‰$H‰D$è    H‹L$ ë¡‰ë‘è    é<ÿÿÿ
      n
  """.loadPrivateKey   š 6runtime.writeBarrierEnabled   Ğ 6runtime.writeBarrierEnabled   ¤
  .runtime.writebarrierptr   Ö
  .runtime.writebarrierptr   ö
  0runtime.morestack_noctxt   P0  "".~r1 0type.error "".path type.string "".signer  type.*"".Signer 0l/0L Ğ &>#4	  6š TgclocalsÂ·1347047f6245a35b91e9a4f213167d52 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş4"".(*Signer).LoadPublicKey     dH‹%    H;avnHƒì1ÛH‰\$8H‰\$@H‹\$(H‰$H‹\$0H‰\$è    H‹D$H‹\$ Hƒû t2€=     uH‰C1ÛH‰\$8H‰\$@HƒÄÃLCL‰$H‰D$è    ëÛ‰ëÊè    éyÿÿÿ

      f
   "".loadPublicKey   ’ 6runtime.writeBarrierEnabled   æ
  .runtime.writebarrierptr   ü
  0runtime.morestack_noctxt   P0  "".~r1 0type.error "".path type.string "".signer  type.*"".Signer 0Q/0+  J5 
 2^ TgclocalsÂ·1347047f6245a35b91e9a4f213167d52 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş2"".(*Signer).SignContents  à  ŞdH‹%    H;a†  Hƒìx1Û1Û1ÛH‰œ$¸   H‰œ$À   1ÛH‰œ$    H‰œ$¨   H‰œ$°   H‹œ$€   H‰$H‹œ$ˆ   H‰\$H‹œ$   H‰\$H‹œ$˜   H‰\$è    H‹t$ H‹T$(H‹L$0H‹    1ÀH‰$H‹    H‰\$H‹œ$€   H‹+H‰l$H‰D$H‰t$`H‰t$ H‰T$hH‰T$(H‰L$pH‰L$0è    H‹\$8H‰œ$    H‹\$@H‰œ$¨   H‹\$HH‰œ$°   H‹\$PH‰œ$¸   H‹\$XH‰œ$À   HƒÄxÃè    éÑşÿÿ
      ö
  0"".(*Signer).HashMessage   ¢  $crypto/rand.Reader   ¼ $crypto/rand.Reader   ¶
  .crypto/rsa.SignPKCS1v15   Ì
  0runtime.morestack_noctxt   ğ  
"".hashed /type.[]uint8 "".err ptype.error """.signedContents @type.[]uint8 "".contents type.[]uint8 "".signer  type.*"".Signer ğïğ °  TGG‰  z¶ TgclocalsÂ·ceeeaa06de8d2a5a22a0a9e77901485d TgclocalsÂ·790e5cc5051fc0affc980ade09e929ec   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş6"".(*Signer).VerifyContents  à  ÔdH‹%    H;a†Í   HƒìhH‹\$pH‰$H‹\$xH‰\$H‹œ$€   H‰\$H‹œ$ˆ   H‰\$è    H‹t$ H‹T$(H‹L$0H‹\$p1ÀH‹kH‰,$H‰D$H‰t$PH‰t$H‰T$XH‰T$H‰L$`H‰L$ H‹œ$   H‰\$(H‹œ$˜   H‰\$0H‹œ$    H‰\$8è    H‹D$@H‹\$HHƒø tÆ„$¨    HƒÄhÃÆ„$¨   HƒÄhÃè    éÿÿÿ
      Š
  0"".(*Signer).HashMessage   ä
  2crypto/rsa.VerifyPKCS1v15   Â
  0runtime.morestack_noctxt   €Ğ  
"".hashed /type.[]uint8 "".~r2 ptype.bool """.signedContents @type.[]uint8 "".contents type.[]uint8 "".signer  type.*"".Signer &Ğ»ÏĞÏĞ ğ &dAa  D¬ TgclocalsÂ·aa1348b48698f87aa280c850484901cc TgclocalsÂ·790e5cc5051fc0affc980ade09e929ec   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş0"".(*Signer).HashMessage  €	  şdH‹%    HD$ğH;A†  Hì   1Û1ÛH‰œ$¸   H‰œ$À   H‰œ$È   1ÛH‰\$@H‰\$HH    H‰$è    H‹L$Ç#Eg½‰«Íï‰i½şÜº˜‰iÇAvT2½ğáÒÃ‰iHÇAX    HÇA`    H‰L$8H‹    1íH9è„[  H‹L$8H‰D$pH‰L$xH‰D$@H‰L$HH‹œ$    H‰\$H‹œ$¨   H‰\$H‹œ$°   H‰\$H‰L$XH‰$H‰D$PH‹X@ÿÓH‹T$ H‹L$(H‰L$`H‹t$0H‰t$hH‹„$¨   H9Â}]H    H‰œ$€   HÇ„$ˆ   W   H    H‰$Hœ$€   H‰\$HÇD$    è    H\$H‹H‰$H‹KH‰L$è    Hƒù t*H‰$H‰t$è    H\$H‹H‰$H‹KH‰L$è    1ÛH‰\$H‰\$H‰\$H‹\$XH‰$H‹\$PH‹[8ÿÓH‹\$ H‰œ$¸   H‹\$(H‰œ$À   H‹\$0H‰œ$È   HÄ   ÃH    H‰$H    H‰\$H    H‰\$è    H‹D$ésşÿÿè    éÁıÿÿ"
      ”  .type.crypto/sha1.digest   ¦
  "runtime.newobject   ²  Jgo.itab.*crypto/sha1.digest.hash.Hash   ô       Ê  Ægo.string."Dalton-Signer : Can't write the entire Message into the hash writer to generate a hash "   €  type.string   ¾
  runtime.convT2E   ò
  runtime.gopanic   
  runtime.convI2E   Ò
  runtime.gopanic   ¤       Œ  0type.*crypto/sha1.digest   ¢  type.hash.Hash   º  Jgo.itab.*crypto/sha1.digest.hash.Hash   Î
   runtime.typ2Itab   ì
  0runtime.morestack_noctxt   p   "".autotmp_0007 ?type.hash.Hash "".autotmp_0006 type.string "".autotmp_0004 ¯0type.*crypto/sha1.digest "".~r0 Ÿtype.hash.Hash "".err _type.error "".sha1 type.hash.Hash """.hashedContents @type.[]uint8 "".message type.[]uint8 "".signer  type.*"".Signer  ãŸ = À 2€;†T]*L2  R¨d0˜ TgclocalsÂ·ffe471b206c7569cb0cc60d42e32041c TgclocalsÂ·04039077eba7fa72130c1e82a2895f98   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş "".loadPublicKey  €  ìdH‹%    H;a†Y  HƒìpH‹\$xH‰$H‹œ$€   H‰\$è    H‹t$H‰t$XH‹l$H‰l$`H‹T$ H‰T$hH‹D$(H‹L$0H‰L$PH‰D$HHƒø t*H‰$H‰L$è    H\$H‹H‰$H‹KH‰L$è    H‰4$H‰l$H‰T$è    H‹\$Hƒû „¯   H[H‹H‰$H‹KH‰L$H‹KH‰L$è    H‹T$H‰T$8H‹L$ H‰L$@H‹D$(H‹l$0H‰l$PH‰D$HHƒø t*H‰$H‰l$è    H\$H‹H‰$H‹KH‰L$è    H-    H9êuH‰Œ$ˆ   HƒÄpÃH‰$H‰l$L    L‰D$è    ‰éJÿÿÿè    éŠşÿÿ
      \
  $io/ioutil.ReadFile   è
  runtime.convI2E   œ
  runtime.gopanic   Æ
  &encoding/pem.Decode   ¨
  <crypto/x509.ParsePKIXPublicKey    
  runtime.convI2E   Ô
  runtime.gopanic   æ  4type.*crypto/rsa.PublicKey   ª  "type.interface {}   ¾
  (runtime.panicdottype   Ú
  0runtime.morestack_noctxt   0à  
"".pubInterface o"type.interface {} "".err Otype.error "".contents /type.[]uint8 "".~r1  4type.*crypto/rsa.PublicKey "".path  type.string à±ßà7 € 0šH*O*5  -Ó TgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2 TgclocalsÂ·627bbca91efe935c3ac76737d2026ca6   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş""".loadPrivateKey  €  ädH‹%    H;a†  Hƒì`H‹\$hH‰$H‹\$pH‰\$è    H‹t$H‰t$HH‹l$H‰l$PH‹T$ H‰T$XH‹D$(H‹L$0H‰L$@H‰D$8Hƒø t*H‰$H‰L$è    H\$H‹H‰$H‹KH‰L$è    H‰4$H‰l$H‰T$è    H‹\$Hƒû tuH[H‹H‰$H‹KH‰L$H‹KH‰L$è    H‹D$H‹L$ H‹T$(Hƒù t4H‰L$8H‰$H‰T$@H‰T$è    H\$H‹H‰$H‹KH‰L$è    H‰D$xHƒÄ`Ã‰ë‡è    éÎşÿÿ
      V
  $io/ioutil.ReadFile   â
  runtime.convI2E   –
  runtime.gopanic   À
  &encoding/pem.Decode   š
  @crypto/x509.ParsePKCS1PrivateKey   ô
  runtime.convI2E   ¨
  runtime.gopanic   Ò
  0runtime.morestack_noctxt   0À  "".err Otype.error "".contents /type.[]uint8 "".~r1  6type.*crypto/rsa.PrivateKey "".path  type.string ÀŒ¿À À 0ºE*74
  *– TgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2 TgclocalsÂ·12fc1489b12fcdedb8fc818b7369b5d9   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş:"".(*Signer).InitSigner.func1  €  âdH‹%    H;a†”   Hƒì@H\$HH‰$è    H‹D$H‹L$Hƒø tY1ÛH‰\$0H‰\$8H    H‰$H‰D$ H‰D$H‰L$(H‰L$H\$0H‰\$è    H‹\$HH‹l$0H‰+H‹l$8€=     u	H‰kHƒÄ@ÃLCL‰$H‰l$è    ëçè    éOÿÿÿ
      B
  "runtime.gorecover   ˆ  type.error   Ö
  "runtime.assertE2I   † 6runtime.writeBarrierEnabled   Â
  .runtime.writebarrierptr   Ğ
  0runtime.morestack_noctxt   €  "".autotmp_0010 type.error "".data ?"type.interface {} "".&err  type.*error €{€- À (Y	   JV TgclocalsÂ·51fa0e13d53d6bad7f86670d3edaeac6 TgclocalsÂ·2c78d3ad9d760b5f66e2e47be684c787   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goş"".init  €  îdH‹%    H;ava¶    €û t¶    €ûuÃè    Æ    è    è    è    è    è    è    è    è    è    è    Æ    Ãè    ë‰"
      $  "".initdoneÂ·   <  "".initdoneÂ·   R
  "runtime.throwinit   b "".initdoneÂ·   n
  fmt.init   x
  $crypto/cipher.init   ‚
  crypto/aes.init   Œ
  crypto/rsa.init   –
  io/ioutil.init    
  "encoding/pem.init   ª
   crypto/x509.init   ´
   crypto/sha1.init   ¾
  crypto.init   È
   crypto/rand.init   Ô "".initdoneÂ·   â
  0runtime.morestack_noctxt        € € 
Ø€ 
 (X TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   ˆ/media/snouto/rest/projects/dalton/dalton/src/dalton/crypt/signer.goşTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·0ebb2d1da58c1b4224bf5a7b370d7578             şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·0ebb2d1da58c1b4224bf5a7b370d7578             şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·3f5c1f818fa7055d0400cecd34057162             ş$"".hdr..gostring.1             s          ""..gostring.1   ş""..gostring.1 ğ  èCryptoManager: You have to initialize KeySize , Symmetric Key and Initialization Vector before using the algorithm.  şTgclocalsÂ·64ca935d1a2110a30e2d604686188539                    şTgclocalsÂ·8b959903a1683cc7c5ff1a0817f89906        	          ş$"".hdr..gostring.2             s          ""..gostring.2   ş""..gostring.2 ğ  èCryptoManager: You have to initialize KeySize , Symmetric Key and Initialization Vector before using the algorithm.  şTgclocalsÂ·64ca935d1a2110a30e2d604686188539                    şTgclocalsÂ·8b959903a1683cc7c5ff1a0817f89906        	          şTgclocalsÂ·a8eabfc4a4514ed6b3b0c61e9680e440              şTgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2             şTgclocalsÂ·69c1753bd5f81501d95132d08af04464           şTgclocalsÂ·61be611d0884f5694642c4f84809f991              k    şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·1347047f6245a35b91e9a4f213167d52             şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·1347047f6245a35b91e9a4f213167d52             şTgclocalsÂ·790e5cc5051fc0affc980ade09e929ec              şTgclocalsÂ·ceeeaa06de8d2a5a22a0a9e77901485d      	       şTgclocalsÂ·790e5cc5051fc0affc980ade09e929ec              şTgclocalsÂ·aa1348b48698f87aa280c850484901cc             ş0Jgo.itab.*crypto/sha1.digest.hash.Hash     şÎgo.string.hdr."Dalton-Signer : Can't write the entire Message into the hash writer to generate a hash "             W          Ægo.string."Dalton-Signer : Can't write the entire Message into the hash writer to generate a hash "   şÆgo.string."Dalton-Signer : Can't write the entire Message into the hash writer to generate a hash " °  °Dalton-Signer : Can't write the entire Message into the hash writer to generate a hash   şTgclocalsÂ·04039077eba7fa72130c1e82a2895f98 0  0                    şTgclocalsÂ·ffe471b206c7569cb0cc60d42e32041c 0  0                   şTgclocalsÂ·627bbca91efe935c3ac76737d2026ca6              şTgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2             şTgclocalsÂ·12fc1489b12fcdedb8fc818b7369b5d9              şTgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2             şTgclocalsÂ·2c78d3ad9d760b5f66e2e47be684c787                   şTgclocalsÂ·51fa0e13d53d6bad7f86670d3edaeac6                  şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           ş0"".initdoneÂ·  type.uint8   ş8"".(*CryptoManager).SetIVÂ·f              2"".(*CryptoManager).SetIV   ş:"".(*CryptoManager).SetKeyÂ·f              4"".(*CryptoManager).SetKey   şB"".(*CryptoManager).SetKeySizeÂ·f              <"".(*CryptoManager).SetKeySize   ş<"".(*CryptoManager).EncryptÂ·f              6"".(*CryptoManager).Encrypt   ş<"".(*CryptoManager).DecryptÂ·f              6"".(*CryptoManager).Decrypt   ş "".makeCipherÂ·f              "".makeCipher   ş4"".(*Signer).InitSignerÂ·f              ."".(*Signer).InitSigner   ş<"".(*Signer).LoadPrivateKeyÂ·f              6"".(*Signer).LoadPrivateKey   ş:"".(*Signer).LoadPublicKeyÂ·f              4"".(*Signer).LoadPublicKey   ş8"".(*Signer).SignContentsÂ·f              2"".(*Signer).SignContents   ş<"".(*Signer).VerifyContentsÂ·f              6"".(*Signer).VerifyContents   ş6"".(*Signer).HashMessageÂ·f              0"".(*Signer).HashMessage   ş&"".loadPublicKeyÂ·f               "".loadPublicKey   ş("".loadPrivateKeyÂ·f              """.loadPrivateKey   ş@"".(*Signer).InitSigner.func1Â·f              :"".(*Signer).InitSigner.func1   ş"".initÂ·f              "".init   ş"runtime.gcbits.01    ş.go.string.hdr."[]uint8"                       &go.string."[]uint8"   ş&go.string."[]uint8"   []uint8  ştype.[]uint8                   ß~.8                                                         0   runtime.algarray   @  "runtime.gcbits.01   P  .go.string.hdr."[]uint8"   p  *go.weak.type.*[]uint8   €  "runtime.zerovalue     type.uint8   ş6go.typelink.[]uint8	[]uint8              type.[]uint8   ş"runtime.gcbits.09   	 şFgo.string.hdr."crypt.CryptoManager"                       >go.string."crypt.CryptoManager"   ş>go.string."crypt.CryptoManager" 0  (crypt.CryptoManager  ş$go.string.hdr."IV"                       go.string."IV"   şgo.string."IV"   IV  ş8go.string.hdr."SymmetricKey"                       0go.string."SymmetricKey"   ş0go.string."SymmetricKey"    SymmetricKey  ş.go.string.hdr."KeySize"                       &go.string."KeySize"   ş&go.string."KeySize"   KeySize  ş:go.string.hdr."CryptoManager"                       2go.string."CryptoManager"   ş2go.string."CryptoManager"    CryptoManager  ş8go.string.hdr."dalton/crypt"                       0go.string."dalton/crypt"   ş0go.string."dalton/crypt"    dalton/crypt  ş"go.importpath."".                       0go.string."dalton/crypt"   ş*type."".CryptoManager  €  €8               ÚãR“                                                                                                                                                                                      0                                                0à  runtime.algarray   @  "runtime.gcbits.09   P  Fgo.string.hdr."crypt.CryptoManager"   p  ,type.*"".CryptoManager   €  "runtime.zerovalue   À *type."".CryptoManager   À  $go.string.hdr."IV"   à  type.[]uint8     8go.string.hdr."SymmetricKey"   °  type.[]uint8   à  .go.string.hdr."KeySize"   €  type.int   `° *type."".CryptoManager   °  :go.string.hdr."CryptoManager"   À  "go.importpath."".   Ğ€ *type."".CryptoManager   şHgo.string.hdr."*crypt.CryptoManager"                       @go.string."*crypt.CryptoManager"   ş@go.string."*crypt.CryptoManager" 0  **crypt.CryptoManager  şˆgo.string.hdr."func(*crypt.CryptoManager, []uint8) ([]uint8, error)"             4          €go.string."func(*crypt.CryptoManager, []uint8) ([]uint8, error)"   ş€go.string."func(*crypt.CryptoManager, []uint8) ([]uint8, error)" p  jfunc(*crypt.CryptoManager, []uint8) ([]uint8, error)  şltype.func(*"".CryptoManager, []uint8) ([]uint8, error) À  À              8×¤Å 3                                                                                                                                    0€  runtime.algarray   @  "runtime.gcbits.01   P  ˆgo.string.hdr."func(*crypt.CryptoManager, []uint8) ([]uint8, error)"   p  ~go.weak.type.*func(*"".CryptoManager, []uint8) ([]uint8, error)   €  "runtime.zerovalue    € ltype.func(*"".CryptoManager, []uint8) ([]uint8, error)   Ğ  ltype.func(*"".CryptoManager, []uint8) ([]uint8, error)   €  ,type.*"".CryptoManager     type.[]uint8      type.[]uint8   °  type.error   şägo.typelink.func(*crypt.CryptoManager, []uint8) ([]uint8, error)	func(*"".CryptoManager, []uint8) ([]uint8, error)              ltype.func(*"".CryptoManager, []uint8) ([]uint8, error)   şfgo.string.hdr."func(*crypt.CryptoManager, []uint8)"             #          ^go.string."func(*crypt.CryptoManager, []uint8)"   ş^go.string."func(*crypt.CryptoManager, []uint8)" P  Hfunc(*crypt.CryptoManager, []uint8)  şJtype.func(*"".CryptoManager, []uint8)                   å%lÓ 3                                                                                                                      0€  runtime.algarray   @  "runtime.gcbits.01   P  fgo.string.hdr."func(*crypt.CryptoManager, []uint8)"   p  \go.weak.type.*func(*"".CryptoManager, []uint8)   €  "runtime.zerovalue    € Jtype.func(*"".CryptoManager, []uint8)   Ğ  Jtype.func(*"".CryptoManager, []uint8)   €  ,type.*"".CryptoManager     type.[]uint8   ş go.typelink.func(*crypt.CryptoManager, []uint8)	func(*"".CryptoManager, []uint8)              Jtype.func(*"".CryptoManager, []uint8)   ş^go.string.hdr."func(*crypt.CryptoManager, int)"                       Vgo.string."func(*crypt.CryptoManager, int)"   şVgo.string."func(*crypt.CryptoManager, int)" @  @func(*crypt.CryptoManager, int)  şBtype.func(*"".CryptoManager, int)                   ÌäB 3                                                                                                                      0€  runtime.algarray   @  "runtime.gcbits.01   P  ^go.string.hdr."func(*crypt.CryptoManager, int)"   p  Tgo.weak.type.*func(*"".CryptoManager, int)   €  "runtime.zerovalue    € Btype.func(*"".CryptoManager, int)   Ğ  Btype.func(*"".CryptoManager, int)   €  ,type.*"".CryptoManager     type.int   şgo.typelink.func(*crypt.CryptoManager, int)	func(*"".CryptoManager, int)              Btype.func(*"".CryptoManager, int)   ş.go.string.hdr."Decrypt"                       &go.string."Decrypt"   ş&go.string."Decrypt"   Decrypt  ş\go.string.hdr."func([]uint8) ([]uint8, error)"                       Tgo.string."func([]uint8) ([]uint8, error)"   şTgo.string."func([]uint8) ([]uint8, error)" @  >func([]uint8) ([]uint8, error)  şFtype.func([]uint8) ([]uint8, error) °  °              ûñ• 3                                                                                                                            0€  runtime.algarray   @  "runtime.gcbits.01   P  \go.string.hdr."func([]uint8) ([]uint8, error)"   p  Xgo.weak.type.*func([]uint8) ([]uint8, error)   €  "runtime.zerovalue    € Ftype.func([]uint8) ([]uint8, error)   Ğ Ftype.func([]uint8) ([]uint8, error)   €  type.[]uint8     type.[]uint8      type.error   ş’go.typelink.func([]uint8) ([]uint8, error)	func([]uint8) ([]uint8, error)              Ftype.func([]uint8) ([]uint8, error)   ş.go.string.hdr."Encrypt"                       &go.string."Encrypt"   ş&go.string."Encrypt"   Encrypt  ş*go.string.hdr."SetIV"                       "go.string."SetIV"   ş"go.string."SetIV"   SetIV  ş:go.string.hdr."func([]uint8)"                       2go.string."func([]uint8)"   ş2go.string."func([]uint8)"    func([]uint8)  ş$type.func([]uint8)                 §{í· 3                                                                                                              0€  runtime.algarray   @  "runtime.gcbits.01   P  :go.string.hdr."func([]uint8)"   p  6go.weak.type.*func([]uint8)   €  "runtime.zerovalue    € $type.func([]uint8)   Ğ $type.func([]uint8)   €  type.[]uint8   şNgo.typelink.func([]uint8)	func([]uint8)              $type.func([]uint8)   ş,go.string.hdr."SetKey"                       $go.string."SetKey"   ş$go.string."SetKey"   SetKey  ş4go.string.hdr."SetKeySize"             
          ,go.string."SetKeySize"   ş,go.string."SetKeySize"    SetKeySize  ş2go.string.hdr."func(int)"             	          *go.string."func(int)"   ş*go.string."func(int)"    func(int)  ştype.func(int)                 „æñ 3                                                                                                              0€  runtime.algarray   @  "runtime.gcbits.01   P  2go.string.hdr."func(int)"   p  .go.weak.type.*func(int)   €  "runtime.zerovalue    € type.func(int)   Ğ type.func(int)   €  type.int   ş>go.typelink.func(int)	func(int)              type.func(int)   ş,type.*"".CryptoManager  Ğ  Ğ              ò©¡ 6                                                                                                                                                                                                                                                                                                                                              B0   runtime.algarray   @  "runtime.gcbits.01   P  Hgo.string.hdr."*crypt.CryptoManager"   p  >go.weak.type.**"".CryptoManager   €  "runtime.zerovalue     *type."".CryptoManager   `  ,type.*"".CryptoManager   Àğ ,type.*"".CryptoManager   ğ  .go.string.hdr."Decrypt"     Ftype.func([]uint8) ([]uint8, error)      ltype.func(*"".CryptoManager, []uint8) ([]uint8, error)   °  6"".(*CryptoManager).Decrypt   À  6"".(*CryptoManager).Decrypt   Ğ  .go.string.hdr."Encrypt"   ğ  Ftype.func([]uint8) ([]uint8, error)   €  ltype.func(*"".CryptoManager, []uint8) ([]uint8, error)     6"".(*CryptoManager).Encrypt      6"".(*CryptoManager).Encrypt   °  *go.string.hdr."SetIV"   Ğ  $type.func([]uint8)   à  Jtype.func(*"".CryptoManager, []uint8)   ğ  2"".(*CryptoManager).SetIV   €  2"".(*CryptoManager).SetIV     ,go.string.hdr."SetKey"   °  $type.func([]uint8)   À  Jtype.func(*"".CryptoManager, []uint8)   Ğ  4"".(*CryptoManager).SetKey   à  4"".(*CryptoManager).SetKey   ğ  4go.string.hdr."SetKeySize"     type.func(int)      Btype.func(*"".CryptoManager, int)   °  <"".(*CryptoManager).SetKeySize   À  <"".(*CryptoManager).SetKeySize   ş"runtime.gcbits.03    ş8go.string.hdr."crypt.Signer"                       0go.string."crypt.Signer"   ş0go.string."crypt.Signer"    crypt.Signer  ş4go.string.hdr."PrivateKey"             
          ,go.string."PrivateKey"   ş,go.string."PrivateKey"    PrivateKey  ş2go.string.hdr."PublicKey"             	          *go.string."PublicKey"   ş*go.string."PublicKey"    PublicKey  ş,go.string.hdr."Signer"                       $go.string."Signer"   ş$go.string."Signer"   Signer  ştype."".Signer  °  °              +vh                                                                                                                                                                                              0À  runtime.algarray   @  "runtime.gcbits.03   P  8go.string.hdr."crypt.Signer"   p  type.*"".Signer   €  "runtime.zerovalue   À type."".Signer   À  4go.string.hdr."PrivateKey"   à  6type.*crypto/rsa.PrivateKey     2go.string.hdr."PublicKey"   °  4type.*crypto/rsa.PublicKey   `à type."".Signer   à  ,go.string.hdr."Signer"   ğ  "go.importpath."".   €° type."".Signer   ş:go.string.hdr."*crypt.Signer"                       2go.string."*crypt.Signer"   ş2go.string."*crypt.Signer"    *crypt.Signer  şhgo.string.hdr."func(*crypt.Signer, []uint8) []uint8"             $          `go.string."func(*crypt.Signer, []uint8) []uint8"   ş`go.string."func(*crypt.Signer, []uint8) []uint8" P  Jfunc(*crypt.Signer, []uint8) []uint8  şLtype.func(*"".Signer, []uint8) []uint8 °  °              |p1 3                                                                                                                            0€  runtime.algarray   @  "runtime.gcbits.01   P  hgo.string.hdr."func(*crypt.Signer, []uint8) []uint8"   p  ^go.weak.type.*func(*"".Signer, []uint8) []uint8   €  "runtime.zerovalue    € Ltype.func(*"".Signer, []uint8) []uint8   Ğ  Ltype.func(*"".Signer, []uint8) []uint8   €  type.*"".Signer     type.[]uint8      type.[]uint8   ş¤go.typelink.func(*crypt.Signer, []uint8) []uint8	func(*"".Signer, []uint8) []uint8              Ltype.func(*"".Signer, []uint8) []uint8   şrgo.string.hdr."func(*crypt.Signer, string, string) error"             )          jgo.string."func(*crypt.Signer, string, string) error"   şjgo.string."func(*crypt.Signer, string, string) error" `  Tfunc(*crypt.Signer, string, string) error  şVtype.func(*"".Signer, string, string) error À  À              å• 3                                                                                                                                    0€  runtime.algarray   @  "runtime.gcbits.01   P  rgo.string.hdr."func(*crypt.Signer, string, string) error"   p  hgo.weak.type.*func(*"".Signer, string, string) error   €  "runtime.zerovalue    € Vtype.func(*"".Signer, string, string) error   Ğ° Vtype.func(*"".Signer, string, string) error   €  type.*"".Signer     type.string      type.string   °  type.error   ş¸go.typelink.func(*crypt.Signer, string, string) error	func(*"".Signer, string, string) error              Vtype.func(*"".Signer, string, string) error   şbgo.string.hdr."func(*crypt.Signer, string) error"             !          Zgo.string."func(*crypt.Signer, string) error"   şZgo.string."func(*crypt.Signer, string) error" P  Dfunc(*crypt.Signer, string) error  şFtype.func(*"".Signer, string) error °  °              ïsi 3                                                                                                                            0€  runtime.algarray   @  "runtime.gcbits.01   P  bgo.string.hdr."func(*crypt.Signer, string) error"   p  Xgo.weak.type.*func(*"".Signer, string) error   €  "runtime.zerovalue    € Ftype.func(*"".Signer, string) error   Ğ  Ftype.func(*"".Signer, string) error   €  type.*"".Signer     type.string      type.error   ş˜go.typelink.func(*crypt.Signer, string) error	func(*"".Signer, string) error              Ftype.func(*"".Signer, string) error   şzgo.string.hdr."func(*crypt.Signer, []uint8) ([]uint8, error)"             -          rgo.string."func(*crypt.Signer, []uint8) ([]uint8, error)"   şrgo.string."func(*crypt.Signer, []uint8) ([]uint8, error)" `  \func(*crypt.Signer, []uint8) ([]uint8, error)  ş^type.func(*"".Signer, []uint8) ([]uint8, error) À  À              j¥Ìö 3                                                                                                                                    0€  runtime.algarray   @  "runtime.gcbits.01   P  zgo.string.hdr."func(*crypt.Signer, []uint8) ([]uint8, error)"   p  pgo.weak.type.*func(*"".Signer, []uint8) ([]uint8, error)   €  "runtime.zerovalue    € ^type.func(*"".Signer, []uint8) ([]uint8, error)   Ğ  ^type.func(*"".Signer, []uint8) ([]uint8, error)   €  type.*"".Signer     type.[]uint8      type.[]uint8   °  type.error   şÈgo.typelink.func(*crypt.Signer, []uint8) ([]uint8, error)	func(*"".Signer, []uint8) ([]uint8, error)              ^type.func(*"".Signer, []uint8) ([]uint8, error)   ştgo.string.hdr."func(*crypt.Signer, []uint8, []uint8) bool"             *          lgo.string."func(*crypt.Signer, []uint8, []uint8) bool"   şlgo.string."func(*crypt.Signer, []uint8, []uint8) bool" `  Vfunc(*crypt.Signer, []uint8, []uint8) bool  şXtype.func(*"".Signer, []uint8, []uint8) bool À  À              Úä­ 3                                                                                                                                    0€  runtime.algarray   @  "runtime.gcbits.01   P  tgo.string.hdr."func(*crypt.Signer, []uint8, []uint8) bool"   p  jgo.weak.type.*func(*"".Signer, []uint8, []uint8) bool   €  "runtime.zerovalue    € Xtype.func(*"".Signer, []uint8, []uint8) bool   Ğ° Xtype.func(*"".Signer, []uint8, []uint8) bool   €  type.*"".Signer     type.[]uint8      type.[]uint8   °  type.bool   ş¼go.typelink.func(*crypt.Signer, []uint8, []uint8) bool	func(*"".Signer, []uint8, []uint8) bool              Xtype.func(*"".Signer, []uint8, []uint8) bool   ş6go.string.hdr."HashMessage"                       .go.string."HashMessage"   ş.go.string."HashMessage"    HashMessage  şJgo.string.hdr."func([]uint8) []uint8"                       Bgo.string."func([]uint8) []uint8"   şBgo.string."func([]uint8) []uint8" 0  ,func([]uint8) []uint8  ş4type.func([]uint8) []uint8                   ›ë& 3                                                                                                                    0€  runtime.algarray   @  "runtime.gcbits.01   P  Jgo.string.hdr."func([]uint8) []uint8"   p  Fgo.weak.type.*func([]uint8) []uint8   €  "runtime.zerovalue    € 4type.func([]uint8) []uint8   Ğ 4type.func([]uint8) []uint8   €  type.[]uint8     type.[]uint8   şngo.typelink.func([]uint8) []uint8	func([]uint8) []uint8              4type.func([]uint8) []uint8   ş4go.string.hdr."InitSigner"             
          ,go.string."InitSigner"   ş,go.string."InitSigner"    InitSigner  şTgo.string.hdr."func(string, string) error"                       Lgo.string."func(string, string) error"   şLgo.string."func(string, string) error" @  6func(string, string) error  ş>type.func(string, string) error °  °              .õĞ„ 3                                                                                                                            0€  runtime.algarray   @  "runtime.gcbits.01   P  Tgo.string.hdr."func(string, string) error"   p  Pgo.weak.type.*func(string, string) error   €  "runtime.zerovalue    € >type.func(string, string) error   Ğ  >type.func(string, string) error   €  type.string     type.string      type.error   ş‚go.typelink.func(string, string) error	func(string, string) error              >type.func(string, string) error   ş<go.string.hdr."LoadPrivateKey"                       4go.string."LoadPrivateKey"   ş4go.string."LoadPrivateKey"    LoadPrivateKey  şDgo.string.hdr."func(string) error"                       <go.string."func(string) error"   ş<go.string."func(string) error" 0  &func(string) error  ş.type.func(string) error                   ŠB”h 3                                                                                                                    0€  runtime.algarray   @  "runtime.gcbits.01   P  Dgo.string.hdr."func(string) error"   p  @go.weak.type.*func(string) error   €  "runtime.zerovalue    € .type.func(string) error   Ğ .type.func(string) error   €  type.string     type.error   şbgo.typelink.func(string) error	func(string) error              .type.func(string) error   ş:go.string.hdr."LoadPublicKey"                       2go.string."LoadPublicKey"   ş2go.string."LoadPublicKey"    LoadPublicKey  ş8go.string.hdr."SignContents"                       0go.string."SignContents"   ş0go.string."SignContents"    SignContents  ş<go.string.hdr."VerifyContents"                       4go.string."VerifyContents"   ş4go.string."VerifyContents"    VerifyContents  şVgo.string.hdr."func([]uint8, []uint8) bool"                       Ngo.string."func([]uint8, []uint8) bool"   şNgo.string."func([]uint8, []uint8) bool" @  8func([]uint8, []uint8) bool  ş@type.func([]uint8, []uint8) bool °  °              w£+  3                                                                                                                            0€  runtime.algarray   @  "runtime.gcbits.01   P  Vgo.string.hdr."func([]uint8, []uint8) bool"   p  Rgo.weak.type.*func([]uint8, []uint8) bool   €  "runtime.zerovalue    € @type.func([]uint8, []uint8) bool   Ğ  @type.func([]uint8, []uint8) bool   €  type.[]uint8     type.[]uint8      type.bool   ş†go.typelink.func([]uint8, []uint8) bool	func([]uint8, []uint8) bool              @type.func([]uint8, []uint8) bool   ştype.*"".Signer  °  °              •ûH 6                                                                                                                                                                                                                                                                                                                                                                                              L0   runtime.algarray   @  "runtime.gcbits.01   P  :go.string.hdr."*crypt.Signer"   p  0go.weak.type.**"".Signer   €  "runtime.zerovalue     type."".Signer   `  type.*"".Signer   Àğ type.*"".Signer   ğ  6go.string.hdr."HashMessage"     4type.func([]uint8) []uint8      Ltype.func(*"".Signer, []uint8) []uint8   °  0"".(*Signer).HashMessage   À  0"".(*Signer).HashMessage   Ğ  4go.string.hdr."InitSigner"   ğ  >type.func(string, string) error   €  Vtype.func(*"".Signer, string, string) error     ."".(*Signer).InitSigner      ."".(*Signer).InitSigner   °  <go.string.hdr."LoadPrivateKey"   Ğ  .type.func(string) error   à  Ftype.func(*"".Signer, string) error   ğ  6"".(*Signer).LoadPrivateKey   €  6"".(*Signer).LoadPrivateKey     :go.string.hdr."LoadPublicKey"   °  .type.func(string) error   À  Ftype.func(*"".Signer, string) error   Ğ  4"".(*Signer).LoadPublicKey   à  4"".(*Signer).LoadPublicKey   ğ  8go.string.hdr."SignContents"     Ftype.func([]uint8) ([]uint8, error)      ^type.func(*"".Signer, []uint8) ([]uint8, error)   °  2"".(*Signer).SignContents   À  2"".(*Signer).SignContents   Ğ  <go.string.hdr."VerifyContents"   ğ  @type.func([]uint8, []uint8) bool   €  Xtype.func(*"".Signer, []uint8, []uint8) bool     6"".(*Signer).VerifyContents      6"".(*Signer).VerifyContents   ş8go.string.hdr."interface {}"                       0go.string."interface {}"   ş0go.string."interface {}"    interface {}  ş"type.interface {} À  À              çW                                                                          0€  runtime.algarray   @  "runtime.gcbits.03   P  8go.string.hdr."interface {}"   p  4go.weak.type.*interface {}   €  "runtime.zerovalue   À "type.interface {}   ş.go.string.hdr."runtime"                       &go.string."runtime"   ş&go.string."runtime"   runtime  ş,go.importpath.runtime.                       &go.string."runtime"   ş&go.string.hdr."fmt"                       go.string."fmt"   şgo.string."fmt"   fmt  ş$go.importpath.fmt.                       go.string."fmt"   ş:go.string.hdr."crypto/cipher"                       2go.string."crypto/cipher"   ş2go.string."crypto/cipher"    crypto/cipher  ş8go.importpath.crypto/cipher.                       2go.string."crypto/cipher"   ş4go.string.hdr."crypto/aes"             
          ,go.string."crypto/aes"   ş,go.string."crypto/aes"    crypto/aes  ş2go.importpath.crypto/aes.             
          ,go.string."crypto/aes"   ş4go.string.hdr."crypto/rsa"             
          ,go.string."crypto/rsa"   ş,go.string."crypto/rsa"    crypto/rsa  ş2go.importpath.crypto/rsa.             
          ,go.string."crypto/rsa"   ş,go.string.hdr."crypto"                       $go.string."crypto"   ş$go.string."crypto"   crypto  ş*go.importpath.crypto.                       $go.string."crypto"   ş6go.string.hdr."crypto/rand"                       .go.string."crypto/rand"   ş.go.string."crypto/rand"    crypto/rand  ş4go.importpath.crypto/rand.                       .go.string."crypto/rand"   ş2go.string.hdr."io/ioutil"             	          *go.string."io/ioutil"   ş*go.string."io/ioutil"    io/ioutil  ş0go.importpath.io/ioutil.             	          *go.string."io/ioutil"   ş8go.string.hdr."encoding/pem"                       0go.string."encoding/pem"   ş0go.string."encoding/pem"    encoding/pem  ş6go.importpath.encoding/pem.                       0go.string."encoding/pem"   ş6go.string.hdr."crypto/x509"                       .go.string."crypto/x509"   ş.go.string."crypto/x509"    crypto/x509  ş4go.importpath.crypto/x509.                       .go.string."crypto/x509"   ş6go.string.hdr."crypto/sha1"                       .go.string."crypto/sha1"   ş.go.string."crypto/sha1"    crypto/sha1  ş4go.importpath.crypto/sha1.                       .go.string."crypto/sha1"   ş"runtime.zerovalue      ÿÿgo13ld 